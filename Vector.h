// ==========================================================================
// Copyright (C) 2000 Fun Key Studios Inc.
// All Rights Reserved.
//
// $Workfile: FKSTLVector.h $
// $Archive: /Common/FKCommon/FKSTLVector.h $
// $Revision: 5 $
//
// Author: Dominic Filion
// Last modified by $Author: Smedan $
// $Modtime: 01-10-30 15:36 $
// --------------------------------------------------------------------------

#pragma once

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CVector
//
///////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> class CVector
{

public:

//	========================================== LIFECYCLE ==========================================

	///////////////////////////////////////////////////////////////////////////////////////////////
	//
	CVector();
	//
	///////////////////////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////////////////////
	//
	virtual ~CVector();
	//
	///////////////////////////////////////////////////////////////////////////////////////////////

//	========================================== OPERATIONS =========================================

	///////////////////////////////////////////////////////////////////////////////////////////////
	//
	void clear();
	//
	///////////////////////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////////////////////
	//
	bool empty()												{ return m_dwSize == 0;				};
	//
	///////////////////////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////////////////////
	//
	void erase( DWORD dwIndex );
	//
	///////////////////////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////////////////////
	//
	int	find( const T& search, DWORD dwStart = 0, DWORD dwEnd = 0 );
	//
	///////////////////////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////////////////////
	//
	void push_back( const T& item );
	//
	///////////////////////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////////////////////
	//
	void pop_back();
	//
	///////////////////////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////////////////////
	//
	void SetGrowSize( DWORD dwSize )							{ m_dwGrowSize = dwSize;			};
	//
	///////////////////////////////////////////////////////////////////////////////////////////////

//	========================================== ACCESS =============================================

	///////////////////////////////////////////////////////////////////////////////////////////////
	//
	T&		operator[]( DWORD dwIndex ) const					{ return m_pItems[dwIndex];			};
	//
	///////////////////////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////////////////////
	//
	DWORD	size() const										{ return m_dwSize;					};
	//
	///////////////////////////////////////////////////////////////////////////////////////////////

//	========================================== INQUIRY ============================================

	T*		m_pItems;

protected :

	DWORD	m_dwSize;
	DWORD	m_dwCapacity;
	DWORD	m_dwGrowSize;

	///////////////////////////////////////////////////////////////////////////////////////////////
	//
	void Grow();
	//
	///////////////////////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////////////////////
	//
	void Shrink();
	//
	///////////////////////////////////////////////////////////////////////////////////////////////

private :

};

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CVector Constructor
//
///////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> CVector<T>::CVector() :
	m_pItems	( NULL	),
	m_dwSize	( 0		),
	m_dwCapacity( 0		),
	m_dwGrowSize( 8		)				// <== ?
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CVector Destructor
//
///////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> CVector<T>::~CVector()
{
	clear();
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CVector::clear()
//
///////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> void CVector<T>::clear()
{
	delete[] m_pItems;
	m_pItems = NULL;
	m_dwSize = 0;
	m_dwCapacity = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CVector::erase()
//
///////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> void CVector<T>::erase( DWORD dwIndex )
{
	// :TODO: Verify this....
//	T* pItem = m_pItems + dwIndex;
	for ( DWORD i = dwIndex; i < m_dwSize - 1; i++ ) m_pItems[i] = m_pItems[i + 1];
	pop_back();
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CVector::find()
//
///////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> int CVector<T>::find( const T& search, DWORD dwStart, DWORD dwEnd )
{
	T* pLast = m_pItems + m_dwSize;
	if ( dwEnd == 0 ) dwEnd = m_dwSize - 1;
	T* pIt = m_pItems + dwStart;
	DWORD i = dwStart;

	while( i != dwEnd && pIt != pLast )
	{
		if ( *pIt == search ) return i;
		i++;
		pIt++;
	}
	if ( pIt && *pIt == search ) return i;
	else return -1;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CVector::Grow()
//
///////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> void CVector<T>::Grow()
{
	T* pNew = new T[m_dwCapacity + m_dwGrowSize];
	if ( m_pItems )
	{
		for ( DWORD i = 0; i < m_dwCapacity; i++ ) pNew[i] = m_pItems[i];
		delete[] m_pItems;
	}
	m_pItems = pNew;
	m_dwCapacity += m_dwGrowSize;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CVector::pop_back()
//
///////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> void CVector<T>::pop_back()
{
	if ( m_dwSize > 0 )
	{
		m_dwSize--;
		if ( m_dwSize == m_dwCapacity - m_dwGrowSize && m_dwCapacity > m_dwGrowSize ) Shrink();
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CVector::push_back()
//
///////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> void CVector<T>::push_back( const T& item )
{
	if ( m_dwSize == m_dwCapacity ) Grow();
	m_pItems[m_dwSize] = item;
	m_dwSize++;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CVector::Shrink()
//
///////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> void CVector<T>::Shrink()
{
	// Could we realloc mem ?
	T* pNew = new T[m_dwCapacity - m_dwGrowSize];
	for ( DWORD i = 0; i < m_dwCapacity - m_dwGrowSize; i++ ) pNew[i] = m_pItems[i];
	delete[] m_pItems;
	m_pItems = pNew;
	m_dwCapacity -= m_dwGrowSize;
}